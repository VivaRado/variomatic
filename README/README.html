<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
		<title>VRD | variomatic | 0.058 | 2020/02/11</title>
		<link rel="icon" href="assets/media/thumb.ico">
		<link rel="stylesheet" type="text/css" href="assets/css/style.css">
		<link rel="stylesheet" type="text/css" href="assets/css/code_native.css">
		<script type="text/javascript" src="assets/js/mermaid.js"></script>
		<script type="text/javascript" src="assets/js/jq.js"></script>
		<script type="text/javascript" src="assets/js/webfont.js"></script>
		<script type="text/javascript" src="assets/js/snap.svg-min.js"></script>
		<script type="text/javascript" src="assets/js/raphael.min.js"></script>
		<script type="text/javascript" src="assets/js/underscore-min.js"></script>
		<script type="text/javascript" src="assets/js/sequence-diagram.js"></script>
		<script type="text/javascript" src="assets/js/flowchart.js"></script>
		<script type="text/javascript" src="assets/js/script.js"></script>

		<script type="text/javascript" src="assets/js/tex-mml-chtml.js"></script>

	</head>
	<body class="markdown">
		<article class="markdown-body" id="body"><div class="sidebar">

<h3><strong>Contents</strong></h3>

<ol>
<li><strong>Introduction</strong>
<ol>
<li><strong>Profile</strong></li>
<li><strong>Project Overview</strong>
<ol>
<li><strong>Background</strong></li>
<li><strong>Need</strong></li>
<li><strong>Scope</strong></li>
<li><strong>Activities</strong></li>
</ol></li>
<li><strong>Organisational Documents</strong></li>
<li><strong>Phase Introduction</strong>
<ol>
<li><strong>Phase Levels</strong></li>
<li><strong>Initiation Phase</strong>
<ol>
<li><strong>Business Case</strong>
<ol>
<li><strong>Solution Options</strong></li>
<li><strong>Strategic case</strong>
<ol>
<li><strong>Contributions</strong></li>
</ol></li>
<li><strong>Management case</strong>
<ol>
<li><strong>Achievements Plan</strong></li>
<li><strong>Timescales</strong></li>
</ol></li>
</ol></li>
<li><strong>Project Charter</strong>
<ol>
<li><strong>Project Introduction</strong>
<ol>
<li><strong>Project Name</strong></li>
<li><strong>Project Statements</strong></li>
<li><strong>Project Definition</strong></li>
</ol></li>
<li><strong>Project Goals</strong></li>
<li><strong>Project Structure</strong></li>
<li><strong>Deliverables</strong></li>
<li><strong>Duration</strong></li>
</ol></li>
</ol></li>
<li><strong>Planning Phase</strong>
<ol>
<li><strong>Safe Planning</strong>
<ol>
<li><strong>Project Plan</strong>
<ol>
<li><strong>Simplification Gradient</strong>
<ol>
<li><strong>Excessive Points Problem</strong></li>
<li><strong>Method Implementation</strong>
<ol>
<li><strong>Simplification</strong></li>
<li><strong>Graph Search</strong></li>
<li><strong>Graph Matching</strong></li>
<li><strong>Line Matching</strong></li>
<li><strong>Naturalisation</strong></li>
</ol></li>
<li><strong>Usage</strong></li>
</ol></li>
<li><strong>Secondary Review</strong></li>
</ol></li>
<li><strong>Work Planning</strong>
<ol>
<li><strong>Task Assignments</strong></li>
<li><strong>Dependencies</strong></li>
</ol></li>
<li><strong>Schedule Planning</strong></li>
</ol></li>
<li><strong>Stakeholders</strong>
<ol>
<li><strong>Personnel Plan</strong></li>
<li><strong>Communication Plan</strong></li>
</ol></li>
<li><strong>Quality Plan</strong>
<ol>
<li><strong>Quality Targets</strong></li>
<li><strong>Quality Management</strong></li>
</ol></li>
</ol></li>
<li><strong>Implementation Phase</strong>
<ol>
<li><strong>Solutions</strong>
<ol>
<li><strong>BATRIC</strong></li>
<li><strong>Revisional</strong>
<ol>
<li><strong>Parts</strong></li>
<li><strong>Mechanisms</strong></li>
<li><strong>Complete Logic</strong></li>
<li><strong>Functions</strong>
<ol>
<li><strong>Function Review</strong></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol>

<h3>Glossary</h3>

<ol>
<li><strong>Glossary</strong></li>
</ol>

<h3>Reference</h3>

<ol>
<li><strong>Reference</strong></li>
</ol>

</div>

<p><img src="assets/media/variomatic_logo.svg" alt="IMG" /></p>

<h2><strong>Introduction</strong></h2>

<p>We at <strong>VivaRado</strong> made this tool to help you with variable fonts!</p>

<hr />

<h3><strong>Introduction / Profile</strong></h3>

<ul>
<li>Company: VivaRado LLP</li>
</ul>

<hr />

<h3><strong>Introduction / Project Overview</strong></h3>

<ul>
<li><p>Project Overview</p>

<ul>
<li>Background</li>
<li>Need</li>
<li>Scope</li>
<li>Activities</li>
<li>Important dates or deadlines</li>
</ul></li>
<li><p>Project Name: Variomatic</p></li>
<li>Proposal Date: 2019/03/04, March fourth of 2019.</li>
</ul>

<hr />

<h3><strong>Introduction / Project Overview / Background</strong></h3>

<p>Google Internationalization, abbreviated to the numeronyms i18n, includes Google Fonts that launched in 2010 to serve webfonts under open-source licenses, by 2016 is serving more than 800 webfont families.</p>

<p>In the context of making the web faster, on 14 September 2016, Adobe, Apple, Google, and Microsoft announced the technology of Variable Fonts, which allows a single font file to store a continuous range of design variants.</p>

<p>An approximation of size reduction, where a family of fonts is about 800kb, by serving a variable font that becomes 100kb, that is about 80% reduction. Let's just say that integrating the whole google fonts library of 800 families to variable format, will be as if google is just serving 100 families, the benefits to server loads and costs are not to be ignored.</p>

<hr />

<h3><strong>Introduction / Project Overview / Need</strong></h3>

<p>There is a need for an automated solution that will be able to "merge", or "make compatible", font instances that are otherwise incompatible.</p>

<blockquote>
  <p>A program that, given 2 incompatible OTFs or TTFs, would make them into a VF with an axis between them.</p>
</blockquote>

<hr />

<h3><strong>Introduction / Project Overview / Scope</strong></h3>

<p>Given the possible reduction the new format presents, we are tasked to create a concept or a working product that will be able to understand and resolve mainly cross instance contour interpolation. That will allow Google Fonts to Variate their whole font directory, subsequently reduce the server loads, increase font quality and designer collaboration.</p>

<hr />

<h3><strong>Introduction / Project Overview / Activities</strong></h3>

<p>Currently identified activities:</p>

<ul>
<li>Present the first phase of documentation (this).</li>
<li>Create and present the Initiation and Planning for the project.</li>
<li>Identify the project tracks that will produce the deliverables.</li>
</ul>

<hr />

<hr />

<h3><strong>Introduction / Phase Introduction</strong></h3>

<p><strong>Initiation Phase</strong>:</p>

<p>The reduction of the server loads is without a doubt the most important benefit. In broad definition to succeed in this task, we are required to create Variable fonts given the existing portfolio.</p>

<p>This document will serve as a reflection of this research being that it will constantly be updated to include the findings and the progress. That is in the hopes that progress will be made.</p>

<hr />

<p><strong>Planning Phase</strong>:</p>

<p>We as VivaRado will need to create an automated solution to variate incompatible fonts to the new variable font format, we are presenting a schedule and the suggested budget, the risks and stakeholders along with the quality expectations.</p>

<hr />

<p><strong>Implementation Phase</strong>:</p>

<p>The work begins by setting and maintaining the planned course, communicating the plan and changes, and monitoring the quality of the work and deliverables.</p>

<hr />

<p><strong>Closure Phase</strong>:</p>

<p>Releasing the final deliverables to the customer, closing documentation and updating organisational documents.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Phase Levels</strong></h3>

<h4>Level 1:</h4>

<p>And a <strong>Project Charter</strong> where the <strong>Project Plan</strong> / <strong>Elements</strong> will be later reflected. Can be thus omitted as is added during Level 1. For the selected <strong>Solution Options</strong>, we start the <strong>Planning Phase</strong> by expressing each of the options as a <strong>Project Plan</strong>. Each <strong>Project Plan</strong> is divided into <strong>Elements</strong>, then those are reflected to the <strong>Work Planning</strong>, <strong>Resource Requirements</strong> for each are identified, <strong>Schedule Planning</strong> and <strong>Budget Planning</strong> is created.</p>

<ul>
<li><p><strong>Minimum Project Management Plan Level 1</strong> Components ∞0.004:</p>

<ol>
<li><strong>Profile</strong></li>
<li><strong>Organisational Documents</strong></li>
<li><strong>Project Overview</strong>
<ol>
<li><strong>Background</strong></li>
<li><strong>Need</strong></li>
<li><strong>Scope</strong></li>
<li><strong>Activities</strong></li>
</ol></li>
<li><strong>Phase Introduction</strong>
<ol>
<li><strong>Phase Levels</strong></li>
<li><strong>Initiation Phase</strong>
<ol>
<li><strong>Business Case</strong>
<ol>
<li><strong>Solution Options</strong></li>
<li><strong>Strategic case</strong></li>
<li><strong>Management case</strong></li>
</ol></li>
<li><strong>Project Charter</strong>
<ol>
<li><strong>Project Introduction</strong>
<ol>
<li><strong>Project Statements</strong></li>
</ol></li>
<li><strong>Project Goals</strong></li>
<li><strong>Project Structure</strong></li>
<li><strong>Deliverables</strong></li>
<li><strong>Duration</strong></li>
</ol></li>
</ol></li>
<li><strong>Planning Phase</strong>
<ol>
<li><strong>Safe Planning</strong>
<ol>
<li><strong>Work Planning</strong>
<ol>
<li><strong>Project Plan</strong>
<ol>
<li><strong>Task Assignments</strong></li>
<li><strong>Dependencies</strong></li>
</ol></li>
<li><strong>Resource Requirements</strong>
<ol>
<li><strong>Scope of Requirements</strong></li>
<li><strong>Production Strategy</strong></li>
</ol></li>
</ol></li>
<li><strong>Schedule Planning</strong></li>
</ol></li>
<li><strong>Stakeholders</strong>
<ol>
<li><strong>Personnel Plan</strong></li>
<li><strong>Communication Plan</strong></li>
</ol></li>
<li><strong>Quality Plan</strong>
<ol>
<li><strong>Quality Targets</strong></li>
<li><strong>Quality Management</strong></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase</strong></h3>

<p>The important elements of the Intiation Phase for Level 1 is the <strong>Business Case</strong>, followed by a <strong>Project Charter</strong>.</p>

<p><strong>Business Case</strong>:</p>

<p>What are the benefits we are trying to get from the project and justification of the decision. It encapsulates the research done to see if the project is worth doing.</p>

<hr />

<p><strong>Project Charter</strong>:</p>

<p>What are the deliverables and the authorisation to do the project. It encapsulates the announcement to do the project.</p>

<hr />

<ul>
<li><p><strong>Initiation Phase</strong> Components ∞0.001:</p>

<ol>
<li><p><strong>Business Case</strong>:</p>

<ul>
<li>Strategic case</li>
<li>Commercial case</li>
<li>Management case</li>
</ul></li>
<li><p><strong>Project Charter</strong>:</p>

<ul>
<li>Project Introduction</li>
<li>Project Goal(s)</li>
<li>Project Structure</li>
<li>Deliverables</li>
<li>Duration</li>
</ul></li>
</ol></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case</strong></h3>

<p>A business case captures the reasoning for initiating the automated variation.</p>

<p>The purpose of a business case is to weigh up the costs and benefits of a suggested course of action and thereby present the argument for a new way of delivering variable fonts.</p>

<hr />

<ul>
<li><strong>Business Case</strong> Components ∞0.003 Level 1:
<ol>
<li><strong>Strategic case</strong></li>
<li><strong>Management case</strong></li>
</ol></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case / Solution Options</strong></h3>

<ul>
<li><p>Currently identified Solution Options:</p>

<ul>
<li>Simplification Gradient (SGRAD)</li>
<li>Bezier Contour Analysis (Future Implementation)</li>
<li>Dynamic Point Repositioning (Future Implementation)</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case / Strategic case</strong></h3>

<p>Given the opportunities by the new format of variable fonts, Google has created tools like fontmake, that includes the varlib, in an attempt to merge compatible instances to variable fonts, effectively creating a paradigm. This enables Google Fonts to set the requirements for the next steps of managing the inconsistencies of those instances that are dubbed incompatible.</p>

<p>VivaRado has been tasked before in handling a case of manually updating an incompatible set of instances, to compatible variation capable instances that produced the new version of Advent font.</p>

<p>During that process VivaRado could identify the elements and conditions this could be possible effectively matching the strategic requirements of Google Fonts in delivering the new variable format, by minimising it's own footprint and server loads.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case / Strategic case / Contributions</strong></h3>

<h4>To Objectives:</h4>

<p>Identified Objectives:</p>

<ul>
<li>Create SGRAD</li>
<li>Integrate the solution to Varlib, FontMake</li>
</ul>

<h4>To Priorities:</h4>

<p>The strategic priorities.</p>

<p>Identified Priorities:</p>

<ol>
<li>SGRAD for non-interpolatable GLIF Files</li>
<li>Bezier Curvature Analysis</li>
<li>Dynamic Point Repositioning</li>
</ol>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case / Management case</strong></h3>

<p>The management case tests the feasibility of the preferred option, in terms of its deliverability within various tolerances.</p>

<h4>Achievability:</h4>

<p>Assessment of Achievability aspects of the project. Its primary purpose is to set out the project organisation and actions which will be undertaken to support the achievement of automatically creating compatible variable interpolation from incompatible contours.</p>

<ul>
<li>Timescales</li>
<li>Available resources</li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case / Management case / Achievements Plan</strong></h3>

<ol>
<li><strong>Milestones</strong>
<ol>
<li>Simplification Script according to Max Error</li>
<li>SGrad</li>
<li>SGrad Graph</li>
</ol></li>
<li><strong>Dependencies</strong></li>
<li><strong>Key Roles</strong></li>
<li><strong>Contingency Plans</strong></li>
<li><strong>Major Risks</strong></li>
<li><strong>Skillset Requirements</strong></li>
</ol>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Business Case / Management case / Timescales</strong></h3>

<p>The suggested contract to solve the Automatic Variation problem:</p>

<p><strong>April 1st 2019</strong> to <strong>December 20th 2019</strong></p>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter</strong></h3>

<ul>
<li><strong>Project Charter</strong> Components ∞0.002:
<ul>
<li>Project Introduction</li>
<li>Project Goals</li>
<li>Project Structure</li>
<li>Business Solution</li>
<li>Deliverables</li>
<li>Duration</li>
<li>Benefits and Limitations</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Project Introduction</strong></h3>

<ul>
<li><p><strong>Project Introduction</strong> Components ∞0.002:</p>

<ul>
<li>Project Name</li>
<li>Project Statements
<ul>
<li>Vision Statement</li>
<li>Mission Statement</li>
</ul></li>
<li>Project Definition
<ul>
<li>Problem </li>
<li>Opportunity</li>
</ul></li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Project Introduction / Project Name</strong></h3>

<ul>
<li>Suggested Names:
<ul>
<li>Variomatic or Vmatic</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Project Introduction / Project Statements</strong></h3>

<h4>Mission Statement:</h4>

<p>Delivering an easy method to review and create variation compatible fonts!</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Project Introduction / Project Definition</strong></h3>

<ul>
<li><p><strong>Problem</strong> Components ∞0.001:</p>

<ul>
<li>Making compatible variation instances requires tedious manual work.</li>
</ul></li>
<li><p><strong>Opportunity</strong> Components ∞0.001:</p>

<ul>
<li>Automatically Create compatible variation instances.</li>
<li>Review incompatibilities.</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Project Goals</strong></h3>

<p>Identified Goals:</p>

<ul>
<li>Working on software to automatically take in a font family with a set of weights and put out a variable font with a weight axis. </li>
<li>That software can depend on GlyphsApp or FontLab6 or RoboFont, although if it works only with fontTools that would be better, but increases the risk.</li>
<li>Create a interpolation layer that only cares about point numbers and contour direction.</li>
<li>Create a Plane that understands contour point warp or movement.</li>
<li>Recreate the contours according to the create layer.</li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Project Structure</strong></h3>

<ul>
<li><strong>Project Structure</strong> Components ∞0.001:
<ul>
<li>Project Scope</li>
<li>Project Team</li>
</ul></li>
</ul>

<hr />

<h4>Project Scope:</h4>

<p>We have divided the project into the <strong>Product Main</strong> that is the <strong>Variomatic</strong>, and <strong>Product Modules</strong>. Each of those parts has its own set of development and design requirements. The project scope will be further updated during the LayerB.</p>

<h4>Project Team:</h4>

<p>The initial team that will provide the deliverables:</p>

<ul>
<li>Andreas Kalpakidis</li>
<li>Madina Akhmatova</li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Business Solution</strong></h3>

<ul>
<li><strong>Business Solution</strong> Components ∞0.001:
<ul>
<li>Approach Options</li>
<li>Possible Technical Solutions</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Deliverables</strong></h3>

<p>This in overview of the deliverables that comprise the proposed solution to the problem of automatically interpolating contours and creating variation capable font instances.</p>

<h4>Deliverable Overview:</h4>

<p>We want to create initially a command line tool that will be able to get a set of fonts, may that be UFOs, create a compound path similarity index by gradually simplifying the contour, then use this Similarity Gradient or SGrad and update, remove, cleanup the original compound contour according to the most needed points identified, without losing curve precision.</p>

<p>We can start by providing .GLIF files directly to the SGRAD script and build the necessary component alphas, then proceed to integrating it to a library, and maybe move in accordance to the structure of VarLib so integration to it could be easier.</p>

<p>This will then allow us to successfully run the fontmake commands and receive the final interpolated variable font.</p>

<p>We want to create an interface, natively in the browser that will allow the user to review the script findings and accept alterations.</p>

<h4>Deliverable Specification:</h4>

<p>Further discussion and updates will be added to this section, that are related to the specifics of functions and features of the deliverables.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Duration</strong></h3>

<ul>
<li><strong>Duration</strong> Components ∞0.001:
<ul>
<li>Timeframe</li>
<li>Milestones</li>
</ul></li>
</ul>

<p>The Timeframe of this project has been set and the Milestones, will be elaborated on in further detail, they are a subject of constant update and will change before we progress further into the Planning Phase.</p>

<h4>Timeframe:</h4>

<p>This project will take place between <strong>April 1st 2019</strong> and until the end of <strong>December 20th 2019</strong>.
The duration is ≃10 months. There is a possibility not to be excluded that a further time frame will be required for a possible implementation of the program to the Google Fonts portfolio, or in case of possible unforeseen risks.</p>

<h4>Milestones:</h4>

<p><strong>Currently Identified Milestones</strong> Components ∞0.001:</p>

<ul>
<li>Create initial demos and tests for the solution of the given problem of automatic interpolation.</li>
<li>Functionality that understands the important contour points and maintains them while removing the excess ones.</li>
<li>Links the points that are related across instances</li>
<li>Use the similarity gradient points as a guide for original point cleanup.</li>
<li>Optimize the font compatible spline system equally across the instances.</li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Initiation Phase / Project Charter / Benefits and Limitations</strong></h3>

<p>Benefits:</p>

<ul>
<li>SGRAD Straight contour matching allows for a relatively good match solving multiple stray points.</li>
<li>Reviewing the output SVGs allows for better understanding of what areas of a contour are problematic</li>
</ul>

<p>Limitations:</p>

<ul>
<li><p>SGRAD cannot always provide 100% results when the contours have major issues.</p></li>
<li><p>the contour sorting fails for non line travel distance sortable, as it tries to calculate the travel distance, of each contour and sort.  For example the inner part of the letter "O" from the outer, is a smaller travel distance in both instances. Where this is not true for glyphs like "=". A approximate position or centroid or barycentric of the contour points, in the glyphs will probably have to be taken into account.</p></li>
<li><p>If end start is in the uncertain lines, final green matching line doesn't visually close.</p></li>
<li><p>If triangle matching and inline check fails for uncertain lines... well there is no matching.</p></li>
<li><p>At the moment there is no final line in a usable list, it is though plotted as green for certain and lime for uncertain basic<em>cleanup and match</em>uncertain_tris.</p></li>
<li><p>This script doesn't do curved bezier contour analysis, it does straight point position comparison across simplification levels. In further iterations we will improve to do bezier contour comparison.</p></li>
<li><p>As it doesn't do curved bezier contour analysis, there is a very small chance the certainty matching gives incorrect matching. But if this happens, there is a chance there are move issues than just that and those issues will be directly visible.</p></li>
<li><p>Adding curved bezier contour analysis will result in 100% matching and cleanup. In respectfully similar contours. Do not expect this to work with two random letters, there is no morphing.</p></li>
<li><p>The script solves only two instances against each other, there is no multiple instance support at this moment.</p></li>
<li><p>The code needs a strong cleanup.</p></li>
<li><p>Networkx should be removed.</p></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase</strong></h3>

<p>The Planning Phase, is where the project solution is further developed in as much detail as possible and the steps necessary to meet the project’s objectives.</p>

<p>The Planning Phase consists of:</p>

<ol>
<li><strong>Safe Planning</strong></li>
<li><strong>Stakeholders</strong></li>
<li><strong>Quality Plan (PQP)</strong></li>
</ol>

<p>At this point, the project would have been planned in detail and is ready to be executed.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning</strong></h3>

<p>The project's <strong>Project Plan</strong> is created outlining the activities, tasks, dependencies, and timeframes. </p>

<ul>
<li><p><strong>Safe Planning</strong> Components (Scope Management): </p>

<ul>
<li>Project Plan:
<ul>
<li>Activities</li>
<li>Tasks</li>
<li>Timeframes</li>
</ul></li>
<li>Work Planning:
<ul>
<li>Dependencies</li>
</ul></li>
<li>Schedule Planning.</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan</strong></h3>

<p>During our initial research we have identified one possible solution that if implemented will successfully produce the required interpolation capable contours. More solutions would be researched.</p>

<ul>
<li><p>Current Plans in Development:</p>

<ul>
<li>Simplification Gradient (SGRAD)</li>
</ul></li>
<li><p>Future Plans:</p>

<ul>
<li>Bezier Curve Analysis</li>
<li>Dynamic Point Repositioning</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Excessive Points Problem</strong></h3>

<h4>Provided Instances</h4>

<p>We are given two instances, one is a Regular and the other is a Bold.
From those for the sake of this example we use a Compound Section.</p>

<p><img src="assets/media/PIP_a_001.svg" alt="IMG" /></p>

<p>image: #001, 0.001, svg, compound section of "&amp;" for regular and bold instances.</p>

<h4>Enumerated Matching</h4>

<p>Enumeration over the point array fails, as there are excessive points and the matching proceeds inconsistently. This results to a failed match and a failed font variation.</p>

<p><img src="assets/media/PIP_a_002.svg" alt="IMG" /></p>

<p>image: #002, 0.001, svg, enumerated matching between given instance compound sections.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Method Implementation</strong></h3>

<p>We present an example of implementing the Simplification Gradient (SGRAD) method over a compound section of a complete glyph.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Method Implementation / Simplification</strong></h3>

<h4>Simplification Gradient on Instance, value Max Error</h4>

<p>We produce a simplification for each compound, iterating the Max Error by 10%.</p>

<p><img src="assets/media/PIP_a_003.svg" alt="IMG" /></p>

<p>image: #003, 0.001, svg, Simplification Gradient - Simplification Gradient.</p>

<hr />

<h4>Point Importance Index. Survival across simplification gradient</h4>

<p>This method due to the results, works on geometric forms, and even then it performs poorly. There is heavy reliance on a simplification algorithm that "prefers" straight lines.
And a possible need of a Curve Fitting algorythm. Tests have been made on rasterizing, then vectorizing and simplifying, a method that might be used to counter very dirty contours that cannot be matched.</p>

<p>Points that we dont need tend to remain longer during simplification. This gives them higher score compared to points that we really need to remain.</p>

<p><small>
<strong>SCHEDULE:</strong> <code>VRM-1001</code>
</small></p>

<hr />

<h4>Product</h4>

<p>Here we can see the SGRAD with the evaluated points from the Simplification Gradient, and how they overlay the original provided compound. Allowing points that are at a minimum of 40% threshold, we can see that there is a matching candidate we can use as a guide. The simplification iteration could be even more granular.</p>

<p><img src="assets/media/PIP_a_006.svg" alt="IMG" /></p>

<p>image: #006, 0.001, svg, Simplification Gradient - Evaluated Overlay SGRAD and Original.</p>

<hr />

<p><img src="assets/media/PIP_a_007.svg" alt="IMG" /></p>

<p>image: #007, 0.001, svg, Simplification Gradient - Cross instance SGRAD Matching.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Method Implementation / Graph Search</strong></h3>

<p>We are creating a positioned graph. Then we can compare the instance graphs since we can create a center node and then see what points are the relatives, judging by the edge and not only by the coordinate similarity. That means that the letters between instance could virtually be located at different coordinates, but still have the same, similar shape, we could still locate them. Since we are evaluating according to graph center.</p>

<p><img src="assets/media/PIP_a_010.svg" alt="IMG" /></p>

<p>image: #010, 0.001, svg, Simplification Gradient - SGrad Graph Comparison.</p>

<p>This logic so far has been proven to work in tests. The logic behind this approach, without the need of SGrad.</p>

<p><strong>Graph Zoom Search</strong>:</p>

<ul>
<li>Parse points across two GLIF instances.</li>
<li>Create a topological graph.</li>
<li>Get center of all coordinates for each instance.</li>
<li>Align instances based on that center.</li>
<li>Create a sorted dictionary with the most distant to the closest, from the center points.</li>
<li>Perform Radius Search for each point, to find the closest point that belongs in the opposite instance.</li>
</ul>

<p>This method works without simplification (^1). Working from the outside towards the inside. We have seen that even complex letters result in a proper match.
This method fails if implemented from the inside towards the outside. So sorting according to most distant to the center is important.
The graph logic so far proves to be appropriate for the solution of the autovariation.</p>

<p><small>
^1: Although RAVS (rasterize-vectorize-simplify) could work if there would be later on comparison of the RAVS instances with the original ones and evaluation of what points we keep and remove.
</small></p>

<hr />

<h4>Finding the Unmatched Points:</h4>

<p>In the image #011, we can see in the produced result of Graph Zoom Search, that there are two points that do not correspond to each instance, marked in red. Those points will be dealt with in Naturalization. But let's see how we got this result.</p>

<p><img src="assets/media/PIP_a_011.svg" alt="IMG" /></p>

<p>image: #011, 0.001, svg, Simplification Gradient - Graph Zoom Search - Unmatched Points.</p>

<hr />

<h4>Radius Match on Graph Zoom Search:</h4>

<p>In the image #012, we can see in the Radius Search looking for nearby points from the opposite instance.</p>

<p><img src="assets/media/PIP_a_012.svg" alt="IMG" /></p>

<p>image: #012, 0.001, svg, Simplification Gradient - Radius Match.</p>

<hr />

<h4>The whole picture:</h4>

<p><img src="assets/media/PIP_a_013.svg" alt="IMG" /></p>

<p>image: #013, 0.001, svg, Simplification Gradient - Graph Zoom Search and Radius Match</p>

<hr />

<h4>Graph Zoom Search:</h4>

<p>In the demo function we have maintained the functionality of simplification as it might later on be required. The given method does not require simplification by what we have seen so far. We can see that the nodes have been sorted according to the distance from the center. Now we will move forward to producing the Radius Match functionality.</p>

<p>We identified a labeling bug in image #014. Where the old version was labeling incorectly. We can see that in comparison to image #015 where the labeling is according to length.</p>

<hr />

<h4>Single Search</h4>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_graph_search.py</code></p>

<p><img src="assets/media/PIP_a_014.svg" alt="IMG" /></p>

<p>image: #014, 0.001, svg, Simplification Gradient - Graph Search actual script product.</p>

<p>Here we can see the Radius Match finding the demo green point, any point above a specific Max Radius is not considered a match.
This will be extended to search points in between instances, by removing matched points from the agreed match array.</p>

<p><img src="assets/media/PIP_a_015.svg" alt="IMG" /></p>

<p>image: #015, 0.001, svg, Simplification Gradient - Graph Search and Radius Match actual script product.</p>

<hr />

<h4>Multiple Search</h4>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_graph_search_multi.py</code></p>

<p>Here we can see RadiusMatch finding the points that match between instances. It has no memory of best match that is why it might match the same points. If it had memory it would know the best matches for each point have been met, depending on distance, and so there would be no matching errors. Other than that the matching is successful, the next step is to implement memory.</p>

<ul>
<li><p>Identified Memory Logic Rules:</p>

<ul>
<li><p>If a point from instance A has been matched with a point from instance B, which has a match with a closer point of instance A, prefer the closer distance point. </p>

<ul>
<li>Avoids points that exist in one but not the other instance.</li>
</ul></li>
<li><p>If a point has been matched but is out of serial order or line (2,6,4), prefer the point that is in serial order or line (2,3,4). </p>

<ul>
<li>Avoids points to be matched, that even though are in close proximity are not on the same line.</li>
<li>Avoids points that exist in one but not the other instance.</li>
</ul></li>
<li><p>There are things we could do with simplification aswell but we have not yet identified issues that lead us to use additional matching rules.</p></li>
</ul></li>
</ul>

<p><img src="assets/media/PIP_a_016.svg" alt="IMG" /></p>

<p>image: #016, 0.001, svg, Simplification Gradient - Graph Search and Radius Match actual script product matching best candidate between regular and light.</p>

<p><a href="https://www.youtube.com/watch?v=UWCHRD1Fp2k&amp;feature=youtu.be">Variomatic TopoGraph RadiusMatch</a></p>

<p>video: #001, 0.001, youtube, Simplification Gradient - Graph Search and Radius Match - screencap.</p>

<hr />

<h4>Ignore Better Matched</h4>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_graph_search_multi.py</code></p>

<p>Here we can see Radius match with one rule added. The rule iterates each instance to instance agreed list, see if match exists in the other instances agreed list and compares the distance, if the distance in the other instances agreed is smaller, it adds that point to ignore. That makes the search leave the smallest distance, and ignore remove the other. We can also see that the points that do not exist in the other instance have no match. Making them removal candidates. Since the removal candidates are now defined and found, we can proceed with the removal and heal of the curves. We noticed that the circles created during the search, where centered on the found node whereas they should be on the node that initiates the search, like a cartoon sonar... During the integration we found that there was a problem with simplification not being drawn, that is now fixed.</p>

<p><img src="assets/media/PIP_a_017.svg" alt="IMG" /></p>

<p>image: #017, 0.001, svg, Simplification Gradient - Graph Search and Radius Match actual script product matching best candidate between regular and light, and ignoring points that do not exist.</p>

<p><a href="https://youtu.be/L_xM--f-Lj0">Variomatic TopoGraph RadiusMatch with Ignore Rule</a></p>

<p>video: #002, 0.001, youtube, Simplification Gradient - Graph Search and Radius Match - Point Ignore Rule - screencap.</p>

<p><small>
<strong>SCHEDULE:</strong> <code>VRM-1003, VRM-1004</code>
</small></p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Method Implementation / Graph Matching</strong></h3>

<h4>Tests and emerging requirements</h4>

<p>During testing we identified a set of additional requirements:</p>

<ul>
<li>The more similarly positioned the instances compared, by applying scale or move, the better the matching.</li>
<li>Simplification and the SGrad will probably be used, as selection of the wrong - easily disgarded paths, by simplification - leads to eroneus matching.</li>
<li>Matching should probably begin at a high simplification level, and gradually add detail, by reducing simplification, while evaluating path matching according to persistance of paths, in addition to cross instance, better-closer distance match.</li>
<li>There is a concept of segmentation of paths. Then comparison of matches to the position.</li>
</ul>

<h4>Example of shape similarity before match</h4>

<p>An example of garamond where we can see the matching difference when some transforms are applied to the shapes before matching. The Radius Search being agnostic in terms of graph cluster comparison, results in wrong matching. But the best results come from just centering the differences of the total coordinate extent, the coordinate centers in both axes.</p>

<p><img src="assets/media/PIP_a_018.svg" alt="IMG" /></p>

<p>image: #018, 0.001, svg, Matching Garamond with shape transforms.</p>

<h4>Cluster Matching</h4>

<p>What the Radius Match is good at finding the clusters, or regions. Even if the point by point results sometimes is matching incorectly, there is a visible similarity in the clusters found for each point. There is also a preset function for rule checking and ignoring paths based on some criteria. The criteria we have tested before is distance based, per point.</p>

<p>Now we will need to go deeper than the <code>letter / contour</code>. We will have to do radius matching on <code>letter / contour / region</code>. Let's see then how we can obtain the clusters or regions. Here we have radius match for Blue instance point 0, that returns a cluster for instance Red. Then we can ask for points from Blue that are in the circle of the most distant match. This provides us with the clusters we need to start our comparison.</p>

<p><img src="assets/media/PIP_a_019.svg" alt="IMG" /></p>

<p>image: #019, 0.001, svg, Obtaining the clusters.</p>

<hr />

<p><img src="assets/media/PIP_a_020.svg" alt="IMG" /></p>

<p>image: #020, 0.001, svg, Red and Blue Clusters for point 0.</p>

<hr />

<h4>Cluster Direction</h4>

<p><img src="assets/media/PIP_a_021.svg" alt="IMG" /></p>

<p>image: #021, 0.001, svg, Determine Cluster Direction and Start Point.</p>

<hr />

<p>Here we are running a direction finding function:</p>

<p>A reminder here that the numbers of the nodes are based on the distance from the center.</p>

<ul>
<li>split everything before the search center.</li>
<li>split the list where there is a smaller number following a larger one.</li>
</ul>

<pre><code>If we are matching for point 0 and the obtained cluster would be:

[3,0,1,2,5,12,11]

The first split would result to:

[0,1,2,5,12,11]

The second split would result to:

[0,1,2,5,12]

Providing us with a list that every value after each value is larger.

</code></pre>

<hr />

<h4>Cluster Matching</h4>

<p>After we overlay the coordinates on the search centers, we can run the same functions Radius Match Search (RMS) with Ignore Better Matched Rule(RIBM), and this will provide us with the correct matches. Onward to integrating this.</p>

<p><img src="assets/media/PIP_a_022.svg" alt="IMG" /></p>

<p>image: #022, 0.001, svg, Cluster center to Start Point and Radius Match with Ignore Better Matched.</p>

<hr />

<p>Here we have the lines being drawn, now we will have to match them (probably by edge angle), then overlay them on the same coordinates, and then run radius match.</p>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_graph_search_lines.py</code></p>

<p><img src="assets/media/PIP_a_023.svg" alt="IMG" /></p>

<p>image: #023, 0.001, svg, Lines created for graph matching.</p>

<p><img src="assets/media/PIP_a_024.svg" alt="IMG" /></p>

<p>image: #024, 0.001, svg, closeup of the lines.</p>

<hr />

<p>Relevant Algorithms:</p>

<ul>
<li>Locality-sensitive hashing</li>
<li>Map Matching</li>
<li>Fréchet distance</li>
<li>Dynamic time warping</li>
</ul>

<p><small>
<strong>SCHEDULE:</strong> <code>VRM-1005, VRM-1006</code>
</small></p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Method Implementation / Line Matching</strong></h3>

<h4>Line Matching Pre and Ante</h4>

<p>From the points that create the line, we designate two observers, before and after the Search Center (SC). One point is pre-SC and the other point is ante-SC. When both observers of the Search Center (SC) verify the same point then have a true Match. From the matching scenarios that are incorrect. We have deducted a methond to fix the matching by using the Ante-Pre method.</p>

<p><img src="assets/media/PIP_a_025.svg" alt="IMG" /></p>

<p>image: #025, 0.001, svg, Pre Ante Rule diagram.</p>

<p>Here are some images from the breakdown of the rule on some cases non the less..</p>

<p><img src="assets/media/PIP_a_026.svg" alt="IMG" /></p>

<p>image: #026, 0.001, svg, Pre Ante Rule example case diagram.</p>

<hr />

<p><img src="assets/media/PIP_a_027.svg" alt="IMG" /></p>

<p>image: #027, 0.001, svg, Pre Ante Rule example case diagram.</p>

<hr />

<p><img src="assets/media/PIP_a_028.svg" alt="IMG" /></p>

<p>image: #028, 0.001, svg, Pre Ante Rule example case diagram.</p>

<hr />

<h4>Line Matching Degree and Distance Based</h4>

<p>The point match is the one that is closest and has the less degree diff between the edge to the current search node and itself. This method was not effective.</p>

<p><img src="assets/media/PIP_a_029.svg" alt="IMG" /></p>

<p>image: #029, 0.001, svg, Degree and Distance based matching</p>

<hr />

<p><img src="assets/media/PIP_a_030.svg" alt="IMG" /></p>

<p>image: #030, 0.001, svg, Degree and Distance example case diagram.</p>

<hr />

<h4>Line Matching Center Transfer Method</h4>

<p>After overview of quite a few methods we have finally founda candidate that is in our opinion the most appropriate. Testing the Center Transfer method proves to work over the scenarios that previous methods failed.</p>

<p>Center Transfer Method Logic:</p>

<ul>
<li>Each instance has a center, both of the centers are at the same coordinates.</li>
<li>For the point that we are running as Search Center (SC).
<ul>
<li>For the point that we are running as Search Center (SC). 
<ul>
<li>Take a line that connects to the center of the instance.</li>
<li>At the point where that line meets the Search Center, create a perpendicular at 90deg to that line (Center Transfer, dashed line)</li>
<li>Locate points from the target instance that are close to the Center Transfer (dashed line) by adding 90deg lines extending to them.</li>
<li>Calculate the distance of those and prefer the smallest distance in terms of drive on the CT line (x axis) and drive on the perpendicular of the CT (y axis) that meets the target point.</li>
</ul></li>
</ul></li>
</ul>

<hr />

<p><img src="assets/media/PIP_a_031.svg" alt="IMG" /></p>

<p>image: #031, 0.001, svg, Center Transfer method running for both instances.</p>

<hr />

<p>From the matching results we can see that the previously mismatched points:</p>

<ul>
<li>Red 11 now matches Blue 12</li>
<li>Blue 4 now doesn't match any of the red points as Blue 7 and Blue 2 have better matches.</li>
</ul>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_graph_search_center_transfer.py</code></p>

<hr />

<h4>Line Matching Center Transfer Surface Method</h4>

<p>We now calculate the surface of the center transfer point and we match all the points successfully BUT 9... Trying to see why that one fails.</p>

<p><img src="assets/media/PIP_a_032.svg" alt="IMG" /></p>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_graph_search_center_transfer_surface.py</code></p>

<p><small>
<strong>SCHEDULE:</strong> <code>VRM-1007-0001</code>
</small></p>

<hr />

<h4>PSCA (Pre, Search Center, Ante) Brokerage</h4>

<pre><code>Target PSCA Match Product 

PRE MATCHES:
[[(8, 15),
 [(13, 20),
 [(20, 21)]
]

SC MATCHES:
[[(15, 19),
 [(16, 18),
 [(9, 16)]
]

ANTE MATCHES:
[[(9, 16),
 [(10, 17),
 [(16, 18)]
]

</code></pre>

<p>We are now tasked with identifying the procedures that will broker the points across the observers (Pre and Ante). One of the methods we will most likely use is to look for series to identify firstly if the source instance Search Center exists at all in the target instance.</p>

<p>If we take a look at the code above we can see lists that refer to the Pre point, that is the point before the given Search Center (the point we are looking to match), and the Ante is the point after the SC. Each match has a tuple with two numbers in it. The first number represents the index based on the distance from the center - graph edge length, and the second number represents the index on the line, of that anchor.</p>

<p>For each of those lists we have 3 matches, this specific piece of matching result is when we are trying to match a point that doesn't exist in the target instance.
By this example we can see that any point in Pre doesn't have a sequence that increments by one point, through the SC until it reaches the Ante, we can see though that Pre(8,15) and Ante(9,16), have an increment of 1, that is proof that the SC doesn't exist at all as a match in the Target Instance.</p>

<p>Expanding on the logic on how to broker those points will provide a solution on matching with precision.</p>

<p>Further on we will use the points in the Match Product to create triangles that we can compare against the Source PSCA triangle and determine what triangle is the best fit for out current SC.</p>

<hr />

<h4>PSCA Triangle Comparison Barymetric Center Extension Angle</h4>

<p><img src="assets/media/PIP_a_033.svg" alt="IMG" /></p>

<p>image: #033, 0.001, svg, Barymetric Center Extension Angle comparisson against triangles</p>

<p>We construct the matching triangles and find the barymetric center, we move the source triangle over the target triangle based on the barymetric centers, then we compare the angles in radians, of the source and target triangle lines, by extending from the barymetric center towards the nodes and comparing SC lines.</p>

<p>We can see that all the points match, and points that don't exist in the target the match returns nothing (red circle).</p>

<p>The more functions we use to compare the triangles the better. In case we see that some results are failing we can devise more triangle comparison functions.</p>

<p>Demo Function Here: <code>python3 lib/graph_search/demo_gscts_psca_tcbcea_a.py</code></p>

<p><a href="https://youtu.be/X_bwzci6Ktg">YouTube Video Here</a></p>

<hr />

<h4>SGRAD Travel Distance Comparisson.</h4>

<p>There are occasions where we get a line that is not correct, for that we implement travel distance comparisson.</p>

<p>We pass the results of the Center Transfer, that carries matches for each of the PSCA points. Then for every of the three matches contained in those three CT items (P, SC, A), we run a get distance from trace.</p>

<p>For each of those points inside each of PSCA we ger a coordinate range of two steps forward and two steps backward for P and A. And for those points we get the most occuring matches according to SGRAD. Then we trace the travel distance for each of those points (get<em>coord</em>range_finder).</p>

<p>We calculate if the point we are traveling is forward in glyph index or backward and assign a penalty if the traveling is going against the stream. On each direction as Pre points are supposed to travel counter clockwise and Ante points Clockwise.</p>

<p>We then evaluate the record and resort the CT results according to that.
This has been found to have a corrective results to lines and later produce better items for the triangle matching.</p>

<hr />

<h4>Results</h4>

<p>After we have run each instance against each other. We have two SGRAD results. We can now use a combiner function to attempt and make the final combinations.</p>

<p>Here we show some of the results that we have gathered. Keep in mind that these pictures are without a combiner function and what we do is get the largest contour , not all the contours, run the variomatic and get the SGRADs that we then connect each points to each other according to SGRAD. Blue letter extends a blue line to the red letter and vice versa. There is also a thinner straight line connecting each point, this is the simlification line.</p>

<p>We can see that when there is a equilibrium in point count, the script returns appropriately matched letters where each SGRAD point looks at the appropriate point on the other instance. Just as you would have if the points where starting from the same location and just iterate each, combining with each, while what we do is completely different we get the same result.</p>

<p>We can also see that when the points are excess or misplaced, there are attempts of connecting to other points across the glyph points.</p>

<p>Because there is a rating for each of those points according to how many times they attempt a connection with the other instance, we can have useful data for the evaluation that we will need in the final combiner function.</p>

<p>I want to stress once more, that there is no attempt to remove or add points at the moment, all the images bellow are from the same run of the script on Garamond Pro Bold and Regular. The lines created are from each SGRAD and the thickness and radius of point circles corresponds to the value of attempts to connect with those points.</p>

<p>We could then get the uncertain areas between high certainty areas, and run an initial triangle matching.
From the points we gather we can then run triangle matching further on points we didn't match, with spamming triangles in intermediate points. We gradually gather the points we need and comprise a line.</p>

<hr />

<p>Review the whole set of initial data at the repository here: </p>

<p><code>lib/batric/output_data/</code></p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Method Implementation / Naturalisation</strong></h3>

<h4>Instance Original Point Naturalisation</h4>

<p>Not implemented yet, but it will be based on remove and heal using fontparts after all the matching rules and quality checks run. Either Keep only overlapping points between the original instances and SGRAD. Or proceed to further Enhancing additional points to the final product. The curve difference must be in accordance to the Curve Difference Quality Target.</p>

<p><img src="assets/media/PIP_a_008.svg" alt="IMG" /></p>

<p>image: #008, 0.001, svg, Simplification Gradient - Cross instance SGRAD Matching.</p>

<hr />

<p><img src="assets/media/PIP_a_009.svg" alt="IMG" /></p>

<p>image: #009, 0.001, svg, Simplification Gradient - Just SGRAD-abduct points from original instances.</p>

<hr />

<h4>Conclusion</h4>

<p>SGRAD if not the easiest method is definitely a promising one. Given that the Max Error can be adjusted to be more granular, this only gives a more precise measurement for what are the points that keep persisting across. Those points are the most important ones and the ones we eventually keep for the final variable interpolation. We think that it provides good enough certainty by using straight no curve lines, and then we can step in and do bezier curve analysis, maybe with dynamic re-positioning.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Simplification Gradient / Usage</strong></h3>

<p>Run <code>python3 lib/batric/sample/main.py</code> with arguments:</p>

<pre><code>
Source UFO Instance Files:

    -a, "--instance_a"
    -b, "--instance_b"

    -a "/font_regular.ufo -b "/font_bold.ufo"

Log Directory for Output:

    -l, "--log_output"

    -l "/log_output"

Run Specific Glyph:

    -g, "--specific_glyph"

Or provide start and end number of glyphs to run:

    -s, "--start_glyph_num"
    -e, "--end_glyph_num"

    Start Glyph Number and End Glyph Number (-s from, -e to): -s 17 -e 117

</code></pre>

<p>For example run:</p>

<pre><code>python3 lib/batric/sample/main.py -a "provide_ufo_a" -b "provide_ufo_b" -l "provide_directory_for_log_output" -g "A"
</code></pre>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Project Plan / Secondary Review</strong></h3>

<p>
Mathjax test:
When \(a \ne 0\), there are two solutions to \(ax^2 + bx + c = 0\) and they are
\[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]
</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Work Planning / Task Assignments</strong></h3>

<p>We have identified a possible solution, and we are waiting for plan approval by Stakeholders.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Work Planning / Dependencies</strong></h3>

<ul>
<li>SGRAD Components ∞0.001:
<ul>
<li>Simplification Gradient:
<ul>
<li>Path, Contour Simplification.
<ul>
<li>According to Threshold Angle.</li>
</ul></li>
<li>Combiner</li>
</ul></li>
<li>SGradient to Instance:
<ul>
<li>Method to transfer the SGradient Guide to the final compounds of each glyph.
<ul>
<li>Point Match according to coordinates.</li>
<li>Method to maintain curve when points are removed.</li>
</ul></li>
</ul></li>
<li>Network X (To be removed)</li>
<li>Plotlib</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Safe Planning / Schedule Planning</strong></h3>

<p>Overview:</p>

<p><strong>2019-10-29 / Publishing initial Variomatic (BATRIC) on GitHub</strong></p>

<pre><span></span><code class='codehilite mermaid'>gantt
    dateFormat  YYYY-MM-DD
    title Variomatic Schedule
    section Initiation Phase
    Plan Approval by Stakeholders:                                                 done, des1, 2019-03-17,1d
    Doc Update to 0.007:                                                           done, des2, 2019-03-18, 1d
    VRM-1001:                                                                      done, des5, 2019-03-30,2019-04-08
    VCF_ONE:                                                                       done, des6, 2019-03-31, 4h
    VRM-1001-demo_simplify.py:                                                     done, des7, 2019-04-02,5h
    VRM-1001-SGrad and SGrad Graph:                                                done, des7, 2019-04-03,12h
    VRM-1002-SGrad Graph Comparison:                                               done, des7, 2019-04-05,3h
    VRM-1003-Graph Zoom Search:                                                    done, des8, 2019-04-06,2019-04-15
    VRM-1004-Radius Match:                                                         done, des9, 2019-04-09,5d
    VRM-1004-Radius Match-Demo:                                                    done, des10, 2019-04-09,4h
    VRM-1004-Radius Match Multi Demo:                                              done, des11, 2019-04-14,8h
    VRM-1004-Radius Match Multi Ignore Rule:                                       done, des12, 2019-04-17,8h
    VRM-1005-PIP test on font glyphs, identify further development targets:        done, des13, 2019-04-18,2019-04-25
    VRM-1006-PIP Implementing test findings RRM:                                   done, des14, 2019-04-25,2019-04-30
    VRM-1006-PIP Demo of Region Radius Match:                                      done, des14, 2019-04-26, 8h
    VRM-1007-Line Matching and Point Validation Logic:                             done, des15, 2019-04-28, 2019-05-02
    VRM-1007-0001 Schematics and Explanation:                                      done, des16, after des15, 2d
    VRM-1008 Line Matching Center Transfer:                                        done, des17, after des16, 12d
    VRM-1008-0001 Line Matching Center Transfer - Surface:                         done, des18, 2019-05-15, 2d
    VRM-1009 PSCA Triangle Comparison Barymetric Center Extension Angle:           done, des19, 2019-06-20, 10d
    First complete matching strategy:                                              done, des21, 2019-07-07, 4h
    Implementation Phase for BATRIC:                                               done, des22, 2019-07-10, 40d
    VRM-1010-0001 BATRIC Line Aggregate:                                           done, des23, 2019-07-26, 16d
    VRM-1010-0002 BATRIC SGRAD:                                                    done, des24, 2019-08-14, 25d
    VRM-1010-0003 BATRIC Complete Font Matcher:                                    done, des25, 2019-09-07, 15d
    VRM-1010-0004 BATRIC Combiner:                                                 done, des26, 2019-09-22, 25d
    VRM-1011 BATRIC Documentation Update:                                                des27, 2019-10-30, 2d
</code></pre>

<p>Schedule:</p>

<ul>
<li><p>Current:</p>

<ul>
<li><strong>Planing and Scheduling</strong> / After P.O.:
<ul>
<li><strong>VRM-1000</strong> Point Importance Plan Scheduling / Andreas Kalpakidis &amp; Madina Akhmatova
<ul>
<li><strong>VRM-1006</strong> Implementing Regional Radius Match (RRM).</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Completed:</p>

<ul>
<li><strike><strong>Assumptions Research</strong> / 2019-March-07 until the end of 2019-March-21</strike>:
<ul>
<li>During the assumptions research we have identified a possible solution, the Point Importance Product.</li>
</ul></li>
<li><strike><strong>Docs LayerA Update</strong> / 2019-March-22</strike>:
<ul>
<li>We have updated the documentation to match that of our initial findings a little early - at March 16</li>
</ul></li>
<li><strike><strong>Plan Approval by Stakeholders</strong> / 2019-March-17</strike>:
<ul>
<li>Plan has been approved and a total has been accepted.</li>
</ul></li>
<li><strike><strong>Doc Update to 0.007</strong> / 2019-March-18</strike>:
<ul>
<li>The documentation has been updated to reflect current status.</li>
</ul></li>
<li><strong>VRM-1001</strong>:
<ul>
<li><strike>One simplification solution implemented. <code>demo_simplify.py</code> 04/02/2019 5h</strike></li>
<li><strike>SGrad and SGrad Graph (topo). 04/03/2019 7h</strike></li>
</ul></li>
<li><strong>VRM-1004</strong>:
<ul>
<li><strike>Radius Match, with demo point match. 2019-04-09, 4h</strike></li>
<li><strike>Radius Match Multi, with demo point match. 2019-04-14, 8h</strike></li>
<li><strike>Radius Match Multi, with ignore rule. 2019-04-17, 8h</strike></li>
</ul></li>
<li><strong>VRM-1005</strong>:
<ul>
<li><strike>PIP Testing different contours. 2019-04-20, 4h</strike></li>
</ul></li>
<li><strong>VRM-1006</strong>:
<ul>
<li><strike>Demo of Region Radius Match. 2019-04-26, 8h</strike></li>
</ul></li>
<li><strong>VRM-1007</strong>:
<ul>
<li><strike>VRM-1007-0001 Schematics and Explanation</strike></li>
</ul></li>
</ul></li>
</ul>

<p>Task Codes:</p>

<ul>
<li>VRM-1001 Simplification</li>
<li>VRM-1002 SGrad</li>
<li>VRM-1003 Graph Zoom Search</li>
<li>VRM-1004 Radius Match</li>
<li>VRM-1005 PIP Testing</li>
<li>VRM-1006 Regional Radius Match</li>
<li>VRM-1007 Line Matching and Point Validation</li>
<li>VRM-1008 Line Matching Center Transfer
<ul>
<li>VRM-1008-0001 Surface</li>
</ul></li>
<li>VRM-1009 Barymetric Triangle Matching by Extension angle</li>
<li>VRM-1010 BATRIC</li>
<li>VRM-1010-0001 Line Aggregate - Perfect Line</li>
<li>VRM-1010 BATRIC
<ul>
<li>VRM-1010-0001 BATRIC Line Aggregate</li>
<li>VRM-1010-0002 BATRIC SGRAD</li>
<li>VRM-1010-0003 BATRIC Complete Font Matcher</li>
<li>VRM-1010-0004 BATRIC Combiner</li>
</ul></li>
<li>VRM-1011 BATRIC Documentation Update</li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Stakeholders</strong></h3>

<p>We identify the <strong>Stakeholders</strong> by a <strong>Personnel Plan</strong> and create a <strong>Communication Plan</strong> to keep the <strong>Stakeholders</strong> informed.</p>

<ul>
<li><p><strong>Stakeholders</strong> Components:</p>

<ul>
<li>Applicable Stakeholders (Conscious and Unconscious Entities):
<ul>
<li>clients</li>
<li>personnel</li>
<li>funders</li>
<li>suppliers</li>
<li>equipment</li>
</ul></li>
<li>Groups
<ul>
<li>Development Group</li>
<li>Organisation Documents Group</li>
<li>Testing Team (TeT)</li>
</ul></li>
<li>Personnel Plan</li>
<li>Communication Plan
<ul>
<li>Stakeholder Feedback Mechanisms</li>
<li>Required notifications</li>
</ul></li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Stakeholders / Personnel Plan</strong></h3>

<ul>
<li><strong>Personnel Plan</strong> Components ∞0.001:
<ul>
<li>Organizational Structure
<ul>
<li>team members
<ul>
<li>internal
<ul>
<li>Andreas Kalpakidis</li>
<li>Madina Akhmatova</li>
</ul></li>
<li>external
<ul>
<li>Dave Crossland</li>
</ul></li>
</ul></li>
</ul></li>
<li>Responsibilities and Qualifications
<ul>
<li>Project Management and Accounting: Madina Akhmatova</li>
<li>Planning and Design: Andreas Kalpakidis</li>
<li>Review and Acceptance: Dave Crossland</li>
</ul></li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Stakeholders / Communication Plan</strong></h3>

<ul>
<li><strong>Communication Plan</strong> Components:
<ul>
<li>Stakeholder Feedback Mechanisms</li>
<li>Required notifications</li>
</ul></li>
</ul>

<h4>Stakeholder Feedback Mechanisms</h4>

<p>Currently the Stakeholders are notified by the README.md and README.html and README.pdf. Stakeholders can be notified by mail or in a forum to be presented soon. Github is also a viable method.</p>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Quality Plan</strong></h3>

<p>A <strong>Quality Plan</strong> describes the activities, standards, tools and processes necessary to achieve quality in the delivery of a project.</p>

<p>We can now create a <strong>Quality Plan</strong> by identifying the valid <strong>Quality Targets</strong> we want to achieve. Identify the <strong>Quality Policies</strong> that will be required to achieve them. Identify how to do <strong>Quality Measurement</strong>. Lastly identify how to maintain quality with <strong>Quality Management</strong>.</p>

<ul>
<li><p><strong>Quality Plan (PQP)</strong> Components:</p>

<ol>
<li>Quality Targets
<ul>
<li>Curve Difference.</li>
</ul></li>
<li>Quality Measurement
<ul>
<li>Combiner and Cross Matching.</li>
</ul></li>
<li>Quality Management</li>
</ol></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Quality Plan / Quality Targets</strong></h3>

<p><strong>Quality Targets</strong> we want to achieve and what are their <strong>Acceptance Criteria</strong>, <strong>Testing Parameters</strong> and <strong>Quality Management Procedures</strong>, for each <strong>Applicable Category</strong></p>

<ol>
<li>Quality Targets Components:
<ul>
<li>Acceptance criteria
<ul>
<li>Identify an acceptable curve difference threshold.</li>
</ul></li>
<li>Testing parameters
<ul>
<li>Applicable Stakeholders</li>
</ul></li>
<li>Quality Management procedures
<ul>
<li>Identify a Curve Precision Difference Calculation procedure.</li>
</ul></li>
</ul></li>
</ol>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Quality Plan / Quality Measurement</strong></h3>

<p>Identify how to do <strong>Quality Measurement</strong> to see if we meet <strong>Performance Standards</strong> and <strong>Acceptance criteria</strong> and how those get collected by our <strong>Performance Documentation Method</strong>.</p>

<ol>
<li>Quality Measurement
<ul>
<li>Performance Standards
<ul>
<li>Performance Documentation Method</li>
</ul></li>
</ul></li>
</ol>

<p>After each instance runs for each level of the simplification seed, creating the SGRAD, we pass the data to the combiner function, we gather point to point cross matching and measure how many times points match each other. This allows for us to understand the quality of matching. Points that do not have cross matching will be lower in quality. While creating the SVG we assign a larger radius to the points that have cross matched more times.</p>

<p>More on this subject and specifics will be presented here in the nearby future. For the moment after we run the function we end up with matching quality levels.</p>

<p>Currently we have 3 quality levels based on uncertainty:</p>

<ul>
<li>Low Uncertainty </li>
<li>Mid Uncertainty </li>
<li>High Uncertainty </li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Planning Phase / Quality Plan / Quality Management</strong></h3>

<p><strong>Quality Management</strong>, the nature of the <strong>Audits</strong>, <strong>Work Verification</strong> by assigning responsible personnel for <strong>Task Fulfillment</strong> and <strong>Task Checking</strong>.</p>

<ol>
<li>Quality Management
<ul>
<li>Audits</li>
<li>Tool Scheduling</li>
<li>Work Verification
<ul>
<li>Task fulfillment responsible personnel</li>
<li>Task checking responsible personnel</li>
</ul></li>
</ul></li>
</ol>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase</strong></h3>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions</strong></h3>

<ul>
<li><p>Researched Solutions:</p>

<ul>
<li>BATRIC
<ul>
<li>Graph Search Outside-In - Center Transfer - Line Matching - Barycentric Triangle Comparisson</li>
</ul></li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / BATRIC</strong></h3>

<p>Needs review of current code structure and update (VRM-1011 BATRIC Documentation Update).</p>

<p>Location: <code>lib/batric</code></p>

<ol>
<li><strong>BATRIC Execution Sequence</strong> Components ∞0.001 to be updated:
<ol>
<li>Initiator <code>init_instances</code>:
<ol>
<li>Initiator Maker <code>make_instances</code>:
<ol>
<li>Simplification Display <code>fitCurve</code></li>
<li>Main Function <code>do_rad_search</code>:
<ol>
<li>Point Matcher Source <code>get_source_matches</code>:
<ol>
<li>Get Encircled <code>in_circle</code></li>
<li>Get Circular Line Index <code>get_line_inx</code></li>
<li>Get Encircled PSCA <code>get_points_around</code></li>
<li>Rotate Points <code>rotate_points</code></li>
<li>Get Point Line <code>get_point_line</code></li>
<li>Plot Point Line <code>plot_region_line</code></li>
<li>Line Check <code>do_line_check</code>
<ol>
<li>Create Center Transfer <code>make_ct</code></li>
<li>Get Barycentric <code>barycentric</code></li>
<li>Compare Triangles <code>triangle_comparisson</code>
<ol>
<li>Get Target Match PSCA <code>evaluate_psca</code></li>
<li>Move Triangle Coordinates <code>move_tri</code></li>
</ol></li>
</ol></li>
</ol></li>
<li>Point Matcher Target <code>get_target_matches</code>:</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol>

<p><strong>Initiator Maker</strong>:</p>

<p>We initiate the instances by providing .glif format strings with 2D vector data. Our instances are divided into Source and Target instances, the Source is considered "gnostic" and the Target "agnostic", because in the Source, having a current_point, we can define our PSCA (Pre, Search Center and Ante points), making it gnostic, in contrast for Target we cannot define those points unless we proceed with creating a line with points matched by the PSCA, making Target agnostic.</p>

<p><strong>Main Function</strong>:</p>

<p>When we have the initiated graphs for each instance (Source and Target), we can obtain a lengthwise list based on the graph center to node - edge length. As we essentially overlap the instances based on the graph center, the barycentric of the graph. This way we avoid iterating points based on their index in the shape as the vectors may have differentiation in point indexing.</p>

<p>We find the immediate points before and after the SC (Search Center), that is the point that we are currently iterating or the most distant point from the center (Outside to Inside). We manage to have a sPSCA for the gnostic or Source side, keeping in mind the circular nature of the sPSCA as it may overlap the line start/end.</p>

<p>Then we attempt to gather the agnostic side points that are at a specific radius from the sPSCA (Source PSCA). If there is nothing found in that radius we assume a "ghost point" and provide the coordinates of the P or A (Pre or Ante) points as matches as we rely on a minimum number of three points so we can identify matches.</p>

<p>We then plot the line on the Source making sure of the appropriate circular indexing where lines should not jump across the shape, and should actually be positioned exactly on the existing lines of the glif vectors.</p>

<p>Proceeding to the creation of the center transfer method that looks for Target points close to the sPSCA line and Source points - according to a perpendicular to the graph center and each sPSCA point, extended infinitely line - by further creating lines from those found target points found inside a radius of the sPSCA points, and sorting based on a created triangle that includes as points ( one: the current sPSCA point, two: the target point that we matched, three: the intersection of the infinite perpendicular line and the line extended from the target matched point), calculate that triangles surface area and we have best Target matches for each of the Source P, SC and Ante points.</p>

<p>Moving on to triangle comparison, we can now create the barycentric of the sPSCA (sPSCA_bar), evaluate the tPSCA triangles according to our rules, and start comparing and matching them to our sPSCA by overlapping them according to barycentric and comparing angles differences, edge lengths surface areas to obtain the best matching.</p>

<p><strong>Aggregate Line</strong>:</p>

<p>We now know if P, SC or A is incorrect and create a new line by combining the other lines. This means that if by increasing radius to gather agnostic points in the target that do not properly create a line, we correct this by always getting 7 points, 3 points from each side of the most favorite to the SC, we do this by using our P and A points as observers, we also know if any of the P SC or A do not exist, we will use this to filter out a perfect agnostic line before triangulation. Now by perfecting triangulation we hope to be able to get 100% best matches in any shape that looks identical.</p>

<h4>Solutions offered</h4>

<p><strong>Not Matching Glyph Order:</strong></p>

<p>One of the solutions helps match the contour order with certainty. Having two contours of unmatched starting points, but even contour lengths, we can produce an appropriate match by either reproducing the contour array according to the match or shifting the contour array according to the match.</p>

<p>We can see the red and blue outline circles that denote the start and end points for each instance don't match. The script solves the start points and equally denotes them with green outline circles.</p>

<p>This also would be the case even if we would have in between points that don't match any other point in a secondary instance, those points would be bypassed and we would still have a proper match. Only in extreme scenarios the matching fails.</p>

<hr />

<p><img src="assets/media/SOL_a_001.svg" alt="IMG" /></p>

<p>image: #034, 0.001, svg, letter "i" with same number of points but not same start point solved. Letter part has unmatched initial start points, the accent has matched initial.</p>

<hr />

<p><img src="assets/media/SOL_a_002.svg" alt="IMG" /></p>

<p>image: #035, 0.001, svg, letter "eight" with same number of points but not same start point solved. External contour starts from the top and the opposite instance starts from the bottom. The solution repositions it to the top. The internal contours have the same start points.</p>

<hr />

<p><img src="assets/media/SOL_a_003.svg" alt="IMG" /></p>

<p>image: #036, 0.001, svg, letter "r" with uneven number of points but same start point solved.</p>

<hr />

<p><small></p>

<p><strong>SCHEDULE:</strong> <code>VRM-1010</code></p>

<p><strong>SCHEDULE:</strong> <code>VRM-1010-0001</code></p>

<p><strong>SCHEDULE:</strong> <code>VRM-1011</code></p>

<p></small></p>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / Revisional</strong></h3>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / Revisional / Parts</strong></h3>

<h3>Parts</h3>

<ul>
<li>V(Instance)
<ul>
<li>Vertices of instace A</li>
</ul></li>
<li>E(Instance)
<ul>
<li>Edges of instace A</li>
</ul></li>
<li>B(Instance)
<ul>
<li>Barycentric Edges of instace A, Function B needs the rest of the instances for δ. Starts count from zero as Barycentric point.</li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / Revisional / Mechanisms</strong></h3>

<h4>Center Transfer Tree (κ, kappa):</h4>

<p>Works only for <strong>B</strong> Barycentric Edges, <code>κB(Vertice Index, Other Instance)</code>. Returns Center Transfer Tree of the provided instance against the other instance.</p>

<h4>Tree (δ, delta):</h4>

<p>On the Current Vertice (cV), we get the Barycentric Vertice it corresponds, we create a perpendicular infinite line (PIL) on that B. Then in the other instances we look for Vertices that are close to that line and create further perpendicular lines extending from those points to meet the PIL. </p>

<p>The intersection point from the other Instances Vertice (oV) to the Current Vertice PIL is called P. The cV, P and oV create a triangle <code>Δ = (cV,P,oV)</code> and an area of the triangle <code>A = (Δ)</code>, we store this for each point for each instance as AreaTriangle (ΔA) that includes <code>ΔA = [ΔA, A(Δ)]</code>. <strong>The ΔA best match is one from ΔA with the smallest Area</strong>.</p>

<p><code>δB(Vertice Index, Other Instance) = sort([ΔA(v23)[A],ΔA(v24)[A],ΔA(v25)[A]]</code></p>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / Revisional / Complete Logic</strong></h3>

<pre><code>i1 = ([x,y], ...)

Instances = (i1, i2, i3)

i1 = (V(i1), E(i1), B(i1, Instances))

for instance i1

    V(i1) = {v1, v2, ..., vn }
    E(i1) = {e1, e2, ..., en }
    B(i1, Instances) = {b0, b1, ..., bn}

provided B(i1) and V(i1) of instance.

    b0 = barycentric of Instance only no kappa.
    b1 = { κB(v1,i2), κB(v1,i3) }
    κB(v1,i2) = { δB(v1,i2),δB(v2,i2) }

</code></pre>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / Revisional / Functions</strong></h3>

<h4>Preparatory Functions</h4>

<p>These functions are used to create the numbers we need to run further comparison logic. We create the graphs and Center Transfer Trees for each Instance.</p>

<ul>
<li>Prep Functions:
<ul>
<li>make_graphs
<ul>
<li>make_v</li>
<li>make_e</li>
<li>make_b</li>
</ul></li>
<li>make_ctt
<ul>
<li>make_delta</li>
</ul></li>
</ul></li>
</ul>

<hr />

<h3><strong>Introduction / Phase Introduction / Implementation Phase / Solutions / Revisional / Functions / Function Review</strong></h3>

<h4>Function make_graphs(Instances)</h4>

<p>Creates Instance Graphs <code>V,E,B(without κB)</code> for provided Instances.</p>

<h4>Permute CTT make_ctt(Instances)</h4>

<p>Populates <code>B</code> in each Instance with <code>κB</code> against other Instances, by building <code>δB</code> for each Instance Vertice leveraging Barycentric Edges.</p>

<hr />

<h3><strong>Glossary</strong></h3>

<p><strong>Compatible Instances</strong>: Font instances or weights, that allow for variation.</p>

<p><strong>SGrad</strong>: Similarity Gradient.</p>

<p><strong>GS</strong>: Graph Zoom Search.</p>

<p><strong>RM</strong>: Radius Match</p>

<hr />

<h3><strong>Reference</strong></h3>

<p><a href="https://github.com/volkerp/fitCurves">fitCurves</a></p>

<p><a href="https://code.google.com/archive/p/graphbook/downloads">google graphbook</a></p>

<hr />
</article>
	</body>
</html>
